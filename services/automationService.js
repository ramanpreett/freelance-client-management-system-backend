import axios from 'axios';
import Client from '../models/Client.js';
import { sendWelcomeEmail } from './emailService.js';

class AutomationService {
  // URL validation helper
  validateUrl(url, platform) {
    if (!url || typeof url !== "string") {
      throw new Error(`Invalid ${platform} URL provided`);
    }
    
    const urlPatterns = {
      linkedin: /linkedin\.com\/in\//i,
      upwork: /upwork\.com\/(?:freelancers|agencies)\//i,
      fiverr: /fiverr\.com\//i
    };
    
    if (urlPatterns[platform] && !urlPatterns[platform].test(url)) {
      throw new Error(`Invalid ${platform} URL format`);
    }
    
    return true;
  }

  // Extract client details from LinkedIn profile URL
  async extractFromLinkedIn(linkedinUrl) {
    this.validateUrl(linkedinUrl, 'linkedin');

    try {
      const extractedName = this.extractNameFromLinkedIn(linkedinUrl);
      const mockData = {
        name: extractedName,
        email: null,
        tags: ['LinkedIn', 'Professional Network'],
        source: 'LinkedIn',
        linkedinUrl,
        notes: `Auto-extracted from LinkedIn profile: ${linkedinUrl}`,
        autoGenerated: true
      };
      return mockData;
    } catch (error) {
      console.error('LinkedIn extraction failed:', error);
      throw new Error('Failed to extract LinkedIn data');
    }
  }

  async extractFromUpwork(upworkUrl) {
    this.validateUrl(upworkUrl, 'upwork');

    try {
      const extractedName = this.extractNameFromUpwork(upworkUrl);
      const mockData = {
        name: extractedName,
        email: null,
        tags: ['Upwork', 'Freelance Platform'],
        source: 'Upwork',
        upworkUrl,
        notes: `Auto-extracted from Upwork profile: ${upworkUrl}`,
        autoGenerated: true
      };
      return mockData;
    } catch (error) {
      console.error('Upwork extraction failed:', error);
      throw new Error('Failed to extract Upwork data');
    }
  }

  async extractFromFiverr(fiverrUrl) {
    this.validateUrl(fiverrUrl, 'fiverr');

    try {
      const extractedName = this.extractNameFromFiverr(fiverrUrl);
      const mockData = {
        name: extractedName,
        email: null,
        tags: ['Fiverr', 'Freelance Platform'],
        source: 'Fiverr',
        fiverrUrl,
        notes: `Auto-extracted from Fiverr profile: ${fiverrUrl}`,
        autoGenerated: true
      };
      return mockData;
    } catch (error) {
      console.error('Fiverr extraction failed:', error);
      throw new Error('Failed to extract Fiverr data');
    }
  }

  async parseEmailContent(emailContent) {
    if (!emailContent || typeof emailContent !== "string" || emailContent.trim().length < 10) {
      throw new Error("Invalid email content provided. Content must be at least 10 characters long.");
    }

    try {
      const extractedName = this.extractNameFromEmail(emailContent);
      const extractedEmail = this.extractEmailFromContent(emailContent);
      const extractedTags = this.extractTagsFromEmail(emailContent);
      
      const extractedData = {
        name: extractedName,
        email: extractedEmail,
        tags: ['Email', ...extractedTags],
        source: 'Email',
        notes: `Auto-parsed from email content. Original content: ${emailContent.substring(0, 200)}${emailContent.length > 200 ? '...' : ''}`,
        autoGenerated: true
      };
      return extractedData;
    } catch (error) {
      console.error('Email parsing failed:', error);
      throw new Error('Failed to parse email content');
    }
  }

  async generateClientProfile(clientData) {
    try {
      const client = new Client({
        name: clientData.name,
        email: clientData.email,
        tags: clientData.tags || [],
        source: clientData.source,
        notes: clientData.notes || `Auto-generated from ${clientData.source}`,
        linkedinUrl: clientData.linkedinUrl,
        upworkUrl: clientData.upworkUrl,
        fiverrUrl: clientData.fiverrUrl,
        autoGenerated: clientData.autoGenerated || false
      });

      await client.save();

      if (client.email) {
        try {
          await this.sendWelcomeEmail(client);
        } catch (emailError) {
          console.error('Welcome email failed:', emailError);
          // Don't fail the entire operation if email fails
        }
      }

      return client;
    } catch (error) {
      console.error('Client profile generation failed:', error);
      throw new Error('Failed to generate client profile');
    }
  }

  async sendWelcomeEmail(client) {
    try {
      const emailData = {
        to: client.email,
        subject: 'Welcome to ClientPulse!',
        template: 'welcome',
        data: {
          clientName: client.name,
          onboardingLink: `${process.env.FRONTEND_URL}/onboarding/${client._id}`
        }
      };

      await sendWelcomeEmail(emailData);
    } catch (error) {
      console.error('Welcome email failed:', error);
    }
  }

  async handleWebhook(payload) {
    try {
      const clientData = {
        name: payload.name,
        email: payload.email,
        tags: payload.tags || [],
        source: payload.source || 'Web Form',
        notes: payload.message || payload.notes
      };

      return await this.generateClientProfile(clientData);
    } catch (error) {
      console.error('Webhook processing failed:', error);
      throw new Error('Failed to process webhook');
    }
  }

  // Helper methods
  extractNameFromLinkedIn(url) {
    try {
      // Handle different LinkedIn URL patterns
      // https://www.linkedin.com/in/john-doe-123456789/
      // https://linkedin.com/in/jane-smith
      const linkedinRegex = /linkedin\.com\/in\/([^\/\?]+)/i;
      const match = url.match(linkedinRegex);
      
      if (match) {
        let namePart = match[1];
        // Remove any trailing numbers or special characters
        namePart = namePart.replace(/[0-9\-_]+$/, '');
        // Convert kebab-case to proper name
        const name = namePart
          .split('-')
          .map(word => word.charAt(0).toUpperCase() + word.slice(1).toLowerCase())
          .join(' ');
        
        return name || 'LinkedIn User';
      }
      
      return 'LinkedIn User';
    } catch (error) {
      console.error('LinkedIn name extraction error:', error);
      return 'LinkedIn User';
    }
  }

  extractNameFromUpwork(url) {
    try {
      // Handle different Upwork URL patterns
      // https://www.upwork.com/freelancers/~0123456789
      // https://www.upwork.com/agencies/~0123456789
      const upworkRegex = /upwork\.com\/(?:freelancers|agencies)\/~([^\/\?]+)/i;
      const match = url.match(upworkRegex);
      
      if (match) {
        // For Upwork, we'll use a generic name since we can't extract the actual name from the URL
        return 'Upwork Client';
      }
      
      return 'Upwork Client';
    } catch (error) {
      console.error('Upwork name extraction error:', error);
      return 'Upwork Client';
    }
  }

  extractNameFromFiverr(url) {
    try {
      // Handle different Fiverr URL patterns
      // https://www.fiverr.com/username
      // https://fiverr.com/seller_name
      const fiverrRegex = /fiverr\.com\/([^\/\?]+)/i;
      const match = url.match(fiverrRegex);
      
      if (match) {
        let username = match[1];
        // Remove any query parameters
        username = username.split('?')[0];
        // Convert to proper name
        const name = username
          .split(/[-_]/)
          .map(word => word.charAt(0).toUpperCase() + word.slice(1).toLowerCase())
          .join(' ');
        
        return name || 'Fiverr User';
      }
      
      return 'Fiverr User';
    } catch (error) {
      console.error('Fiverr name extraction error:', error);
      return 'Fiverr User';
    }
  }

  extractNameFromEmail(content) {
    try {
      // Multiple patterns to extract name from email content
      const patterns = [
        /(?:from|by|contact|sender):\s*([A-Za-z\s]+)/i,
        /(?:my name is|i am|i'm)\s+([A-Za-z\s]+)/i,
        /(?:regards|best regards|sincerely),?\s*([A-Za-z\s]+)/i,
        /(?:hello|hi|dear)\s+([A-Za-z\s]+)/i
      ];
      
      for (const pattern of patterns) {
        const match = content.match(pattern);
        if (match && match[1]) {
          const name = match[1].trim();
          if (name.length > 2 && name.length < 50) {
            return name;
          }
        }
      }
      
      return 'Email Client';
    } catch (error) {
      console.error('Email name extraction error:', error);
      return 'Email Client';
    }
  }

  extractEmailFromContent(content) {
    try {
      const emailRegex = /[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}/g;
      const matches = content.match(emailRegex);
      
      if (matches && matches.length > 0) {
        // Return the first valid email found
        return matches[0];
      }
      
      return null;
    } catch (error) {
      console.error('Email extraction error:', error);
      return null;
    }
  }

  extractTagsFromEmail(content) {
    try {
      const tags = [];
      const lowerContent = content.toLowerCase();
      
      // Project type tags
      if (lowerContent.includes('website') || lowerContent.includes('web development')) tags.push('Web Development');
      if (lowerContent.includes('mobile app') || lowerContent.includes('ios') || lowerContent.includes('android')) tags.push('Mobile Development');
      if (lowerContent.includes('design') || lowerContent.includes('ui/ux')) tags.push('Design');
      if (lowerContent.includes('marketing') || lowerContent.includes('seo')) tags.push('Marketing');
      if (lowerContent.includes('content') || lowerContent.includes('writing')) tags.push('Content Creation');
      
      // Priority tags
      if (lowerContent.includes('urgent') || lowerContent.includes('asap') || lowerContent.includes('immediately')) tags.push('Urgent');
      if (lowerContent.includes('long term') || lowerContent.includes('ongoing') || lowerContent.includes('continuous')) tags.push('Long-term');
      if (lowerContent.includes('budget') || lowerContent.includes('affordable') || lowerContent.includes('cost-effective')) tags.push('Budget-conscious');
      
      // Project size tags
      if (lowerContent.includes('small') || lowerContent.includes('simple')) tags.push('Small Project');
      if (lowerContent.includes('large') || lowerContent.includes('complex') || lowerContent.includes('enterprise')) tags.push('Large Project');
      
      return tags;
    } catch (error) {
      console.error('Email tag extraction error:', error);
      return [];
    }
  }
}

export default new AutomationService();
